diff --git a/config/config_build.json b/config/config_build.json
index f564adc..28a1a9f 100644
--- a/config/config_build.json
+++ b/config/config_build.json
@@ -1,9 +1,9 @@
 {
-	"host": "162.251.164.166",
+	"host": "192.168.1.10",
     "port": 1340,
     "useLocalAPI": false,
     "dispatcher": false,
-    "version":67,
+    "version":68,
     "updatepage":"https://play.google.com/store/apps/details?id=com.retrorpgonline2"
 }
 
diff --git a/config/config_local.json b/config/config_local.json
index 7c69e32..c13fda7 100644
--- a/config/config_local.json
+++ b/config/config_local.json
@@ -1,5 +1,5 @@
 {
-    "host": "162.251.164.166",
+    "host": "192.168.1.10",
     "port": 1340,
     "useLocalAPI": false,
     "dispatcher": false
diff --git a/js/character.js b/js/character.js
index 504d8aa..28e4cce 100644
--- a/js/character.js
+++ b/js/character.js
@@ -158,7 +158,9 @@ define(['entity', 'transition', 'timer', 'mobdata', 'npcdata'], function(Entity,
         },
 
         requestPathfindingTo: function(x, y) {
-            if(this.request_path_callback) {
+        	if (Array.isArray(this.path) && this.path.length>0) {
+            	return this.path;
+        	} else if(this.request_path_callback) {
                 return this.request_path_callback(x, y);
             } else {
                 log.error(this.id + " couldn't request pathfinding to "+x+", "+y);
@@ -367,6 +369,10 @@ define(['entity', 'transition', 'timer', 'mobdata', 'npcdata'], function(Entity,
             }
         },
         
+        lookAt: function(gridX, gridY) {
+            this.turnTo(this.getOrientationTo({gridX: gridX, gridY: gridY}));
+        },
+        
         /**
          *
          */
@@ -456,12 +462,12 @@ define(['entity', 'transition', 'timer', 'mobdata', 'npcdata'], function(Entity,
          * @param {Character} character The character to face.
          * @returns {String} The orientation.
          */
-        getOrientationTo: function(character) {
-            if(this.gridX < character.gridX) {
+        getOrientationTo: function(object) {
+            if(this.gridX < object.gridX) {
                 return Types.Orientations.RIGHT;
-            } else if(this.gridX > character.gridX) {
+            } else if(this.gridX > object.gridX) {
                 return Types.Orientations.LEFT;
-            } else if(this.gridY > character.gridY) {
+            } else if(this.gridY > object.gridY) {
                 return Types.Orientations.UP;
             } else {
                 return Types.Orientations.DOWN;
diff --git a/js/game.js b/js/game.js
index 5171dcf..6a58971 100644
--- a/js/game.js
+++ b/js/game.js
@@ -1507,9 +1507,6 @@ define(['localforage', 'infomanager', 'bubble', 'renderer', 'map', 'animation',
                     });*/
                     
                     self.player.onBeforeMove(function() {
-			    //self.client.sendMoveEntity2(self.player.id,
-				    //self.player.path[self.player.path.length-1][0],
-				    //self.player.path[self.player.path.length-1][1], 1, self.player.orientation);                            
                         // TODO - Sometimes isnt called so next zone isnt loaded.
                         if(self.isZoningTile(self.player.gridX, self.player.gridY))
                         {
@@ -1530,35 +1527,7 @@ define(['localforage', 'infomanager', 'bubble', 'renderer', 'map', 'animation',
                     });
 
                     self.player.onStep(function() {
-                    	// TODO - Replace with map doors.
-                    	//if (!self.player.stoppedTeleport)
-                    	//{	
-							if (self.mapIndex==0 && self.player.gridX == 24 && self.player.gridY == 18)
-							{
-								self.teleportMaps(self.player.id);
-								//return;
-							}
-							if ((self.mapIndex==1 && self.player.gridX == 32 && self.player.gridY == 24) &&
-								self.player.pvpSide == 2)
-							{
-								
-								self.teleportMaps(0);
-								//return;
-							}
-							if ((self.mapIndex==1 && self.player.gridX == 32 && self.player.gridY == 111) &&
-								self.player.pvpSide == 1)
-							{
-								
-								self.teleportMaps(0);
-								//return;
-							}
-							if (self.mapIndex==2 && self.player.gridX == 1 && self.player.gridY == 1)
-							{
-								self.teleportMaps(0);
-								//return;
-							}   
-                        //}
-                        
+
                         if(self.player.hasNextStep()) {
                         	//self.player.stoppedTeleport = false;
                             self.registerEntityDualPosition(self.player);
@@ -1586,8 +1555,9 @@ define(['localforage', 'infomanager', 'bubble', 'renderer', 'map', 'animation',
                         	self.player.moveUp ||
                         	self.player.moveDown)
                         {
-							self.client.sendMoveEntity2(self.mapIndex,
+							self.client.sendMoveEntity2(
 								self.player.id,
+								self.mapIndex,
 								self.player.gridX,
 								self.player.gridY, 2, self.player.orientation,
 									(self.player.target) ? self.player.target.id : 0);
@@ -1616,7 +1586,7 @@ define(['localforage', 'infomanager', 'bubble', 'renderer', 'map', 'animation',
                         if (x==0 && y==0) // Fake move.
                         	return;
                         //if (!self.player.hasNextStep())
-                        	self.client.sendMoveEntity2(self.mapIndex, self.player.id, x, y, 2, self.player.orientation,
+                        	self.client.sendMoveEntity2(self.player.id, self.mapIndex, x, y, 2, self.player.orientation,
                         		self.player.target ? self.player.target.id : 0);
                  
                         if(self.player.hasTarget()) {
@@ -1775,10 +1745,9 @@ define(['localforage', 'infomanager', 'bubble', 'renderer', 'map', 'animation',
                         var path = self.findPath(self.player, x, y, ignored);
                         if (path && path.length > 0)
                         {
-               				    self.client.sendMoveEntity2(self.mapIndex, self.player.id,
-               				    	path[path.length-1][0],
-               				    	path[path.length-1][1], 1, self.player.orientation, 
-               				    	self.player.target ? self.player.target.id : 0);                            
+               				    self.client.sendMovePath(self.mapIndex, self.player.id,
+               				    	path.length,
+               				    	path);                            
 				        }
                         
 						for(var i = 0; i < self.player.pets.length; ++i)
@@ -2063,14 +2032,14 @@ define(['localforage', 'infomanager', 'bubble', 'renderer', 'map', 'animation',
                                                 //entity.setGridPosition(x,y);
                                                 self.registerEntityPosition(entity);
                                                 if (entity instanceof Pet && self.player.id == entity.playerId)
-                                            	    self.client.sendMoveEntity2(self.mapIndex, entity.id, x, y, 2, entity.orientation,
+                                            	    self.client.sendMoveEntity2(entity.id, self.mapIndex, x, y, 2, entity.orientation,
                                             	    	entity.target ? entity.target.id : 0);                                                
                                             }
                                         });
 
                                         entity.onRequestPath(function(x, y) {
-                                            //if (entity instanceof Pet)
-                                            // 	    return self.findPath(entity, x, y);
+                                            if (path) return;
+
                                             var include = [];
                                             var ignored = [entity], // Always ignore self
                                                 ignoreTarget = function(target) {
@@ -2125,7 +2094,7 @@ define(['localforage', 'infomanager', 'bubble', 'renderer', 'map', 'animation',
                                             if (path)
                                             {
                                                 if (entity instanceof Pet && self.player.id == entity.playerId)
-                                            	    self.client.sendMoveEntity2(self.mapIndex, entity.id, x, y, 1, entity.orientation,
+                                            	    self.client.sendMoveEntity2(entity.id, self.mapIndex, x, y, 1, entity.orientation,
                                             	    	entity.target ? entity.target.id : 0);
                                             	self.registerEntityPosition(entity);
                                             	//log.info("path.path="+JSON.stringify(path));
@@ -2314,7 +2283,7 @@ define(['localforage', 'infomanager', 'bubble', 'renderer', 'map', 'animation',
                                		entity.setTarget(target);	
                                	}
                                	
-                               	//REDO - ALgorithm
+                               	// Works pretty good now.
                                 if (self.player && (Math.abs(self.player.gridX - entity.gridX) > self.moveEntityThreshold &&
                                 	Math.abs(self.player.gridY - entity.gridY) > self.moveEntityThreshold) &&
                                     (Math.abs(self.player.gridX - x) >= self.moveEntityThreshold &&
@@ -2323,7 +2292,6 @@ define(['localforage', 'infomanager', 'bubble', 'renderer', 'map', 'animation',
                                 	self.unregisterEntityPosition(entity);
                                 	entity.setGridPosition(x, y);
                                 	self.registerEntityPosition(entity);
-                                	//entity.forceStop();
                                 	entity.updateCharacter = false;
                                 }
                                 else
@@ -2331,11 +2299,45 @@ define(['localforage', 'infomanager', 'bubble', 'renderer', 'map', 'animation',
                                 	self.makeCharacterGoTo(entity, x, y);
                                 	entity.updateCharacter = true;
                                 }
-                                //self.makeCharacterGoTo(entity, x, y);
                             }
                         }
                     });
 
+
+                    self.client.onEntityMovePath(function(map, id, o, path) {
+                        var entity = null;
+
+                        if(id !== self.playerId) {
+                            entity = self.getEntityById(id);
+                            
+                            if (!entity)
+                            	self.unknownEntities.push(id);
+
+                            if(entity && !entity.isDying && !entity.isDead) {
+                                //entity.setOrientation(o);
+                               	
+                                if (self.player && (Math.abs(self.player.gridX - entity.gridX) > self.moveEntityThreshold &&
+                                	Math.abs(self.player.gridY - entity.gridY) > self.moveEntityThreshold) &&
+                                    (Math.abs(self.player.gridX - x) >= self.moveEntityThreshold &&
+                                	Math.abs(self.player.gridY - y) >= self.moveEntityThreshold))
+                                {
+                                	self.unregisterEntityPosition(entity);
+                                	entity.setGridPosition(path[path.length-1][0], path[path.length-1][1]);
+                                	self.registerEntityPosition(entity);
+                                	entity.updateCharacter = false;
+                                }
+                                else
+                                {
+                                	entity.path = path;
+                                	entity.step = 0;
+                                	entity.lookAt(path[0][0], path[0][1]);
+                                    entity.updateCharacter = true;
+                                }
+                            }
+                        }    		
+                    });
+
+
                     self.client.onEntityDestroy(function(id) {
                         var entity = self.getEntityById(id);
                         if(entity) {
@@ -2922,7 +2924,7 @@ define(['localforage', 'infomanager', 'bubble', 'renderer', 'map', 'animation',
                 	}
                     	if (entity && target)
                     	{
-                    		entity.go(x, y);
+                    		//entity.go(x, y);
                     		entity.aggro(target);
                     		entity.lookAtTarget2(target);
                     	}
@@ -3394,37 +3396,44 @@ define(['localforage', 'infomanager', 'bubble', 'renderer', 'map', 'animation',
                 }
             },
 
+            makePlayerAttackFirst: function(mob) {
+            	var self = this;
+            	self.makePlayerAttack(mob);
+				self.client.sendMoveEntity2(
+					self.player.id,
+					self.mapIndex,
+					self.player.gridX,
+					self.player.gridY, 2, self.player.orientation,
+						(self.player.target) ? self.player.target.id : 0);
+            },
+            
             /**
              *
              */
             makePlayerAttack: function(mob) {
-		if (!this.player || this.player == mob) // sanity check.
-			return;
-		
-		var container = "#combatContainer";		
-		var self = this;
-								
-		if (self.player && !self.player.isDead) {
-			if (mob.isDead) 
-			{
-				self.player.removeTarget();
-				return;
-			}
-			if (self.player.withinAttackRange(mob))
-			{
-				if ($(container+":visible").length == 0)
-				    $(container).fadeIn('fast');				
-				//$(container).children().each(function () {
-				//	if ($(this).hasClass("lightup"))
-				//	{
-					    self.player.attackType = $(this).index();
-					    self.client.sendHit(mob,  self.player.attackType);
-					    self.player.hitmob = true;
-					    self.player.skillHandler.showActiveSkill();
-				//	}
-				//});
-			}
-		}
+				if (!this.player || this.player == mob) // sanity check.
+					return;
+				
+				var container = "#combatContainer";		
+				var self = this;
+										
+				if (self.player && !self.player.isDead) {
+					if (mob.isDead) 
+					{
+						self.player.removeTarget();
+						return;
+					}
+					if (self.player.withinAttackRange(mob))
+					{
+						if ($(container+":visible").length == 0)
+							$(container).fadeIn('fast');
+						
+						//self.player.attackType = $(this).index();
+						self.client.sendAttack(self.player, mob);
+						self.player.hitmob = true;
+						self.player.skillHandler.showActiveSkill();
+					}
+				}
             },
 
             /**
@@ -4100,7 +4109,7 @@ define(['localforage', 'infomanager', 'bubble', 'renderer', 'map', 'animation',
 								this.makeAttackerFollow(this.player);
 						}
 						this.player.attackingMode = true;
-						this.makePlayerAttack(entity);
+						this.makePlayerAttackFirst(entity);
 						return;
                     } else if(entity instanceof Item) {
                         this.makePlayerGoToItem(entity);
diff --git a/js/gameclient.js b/js/gameclient.js
index 36c4478..dffbac1 100644
--- a/js/gameclient.js
+++ b/js/gameclient.js
@@ -1,7 +1,8 @@
 
 /* global Types, log, Class */
 
-define(['lib/pako', 'player', 'entityfactory', 'mob', 'mobdata', 'gather', 'gatherdata', 'pet', 'lib/bison', 'config', 'chathandler', 'pvpbase', 'house','guild'], function(pako, Player, EntityFactory, Mob, MobData, Gather, GatherData, Pet, BISON, config, ChatHandler, PvpBase, House, Guild) {
+define(['lib/pako', 'player', 'entityfactory', 'mob', 'mobdata', 'gather', 'gatherdata', 'pet', 'lib/bison', 'config', 'chathandler', 'pvpbase', 'house','guild', 'timer'],
+	function(pako, Player, EntityFactory, Mob, MobData, Gather, GatherData, Pet, BISON, config, ChatHandler, PvpBase, House, Guild, Timer) {
 
     var GameClient = Class.extend({
         init: function(game, host, port, useServer) {
@@ -24,6 +25,7 @@ define(['lib/pako', 'player', 'entityfactory', 'mob', 'mobdata', 'gather', 'gath
             this.handlers[Types.Messages.PLAINLOGIN] = this.recievePlainLogin;
             this.handlers[Types.Messages.WELCOME] = this.receiveWelcome;
             this.handlers[Types.Messages.MOVE] = this.receiveMove;
+            this.handlers[Types.Messages.MOVEPATH] = this.receiveMovePath;
             this.handlers[Types.Messages.LOOTMOVE] = this.receiveLootMove;
             this.handlers[Types.Messages.ATTACK] = this.receiveAttack;
             this.handlers[Types.Messages.SPAWN] = this.receiveSpawn;
@@ -106,7 +108,7 @@ define(['lib/pako', 'player', 'entityfactory', 'mob', 'mobdata', 'gather', 'gath
             setInterval(function() {
                 if (self.rawpackets && self.rawpackets.length > 0)
             	{
-            	    var startDate = new Date();
+            	    //var startDate = new Date();
 			if (self.rawpackets.length == 0)
 				return;
 			var data = self.rawpackets.shift();
@@ -155,34 +157,51 @@ define(['lib/pako', 'player', 'entityfactory', 'mob', 'mobdata', 'gather', 'gath
 					}
 				}				
 			}
-			var endDate = new Date();
-			var time = endDate.getTime() - startDate.getTime()
+			//var endDate = new Date();
+			//var time = endDate.getTime() - startDate.getTime()
 			//if (time > 0)
 				//log.info("Raw Packet burst: " + (time) + "ms");
             	}
-            },12);
-            
-            setInterval(function() {
+            },16);
+
+            self.packetInterval = 32;
+            self.packetProcFunc = (function() {
                 if (self.packets && self.packets.length > 0)
             	{
-            		var startDate = new Date();
+            		self.packetInterval = 32;
+            		//var startDate = new Date();
 					for (var i=0; i < burst; ++i)
 					{
 							if (self.packets.length == 0)
 								return;
 							var data = self.packets.shift();
+							if (data[0] == Types.Messages.WELCOME)
+								self.packetInterval += 500;
 							log.info("live packet: "+data);
 							self.receiveAction(data);
 					}
-					var endDate = new Date();
-					var time = endDate.getTime() - startDate.getTime()
+					//var endDate = new Date();
+					//var time = endDate.getTime() - startDate.getTime()
 					//if (time > 0)
 						//log.info("Packet burst: " + (time) + "ms");
             	}
-            },24);
+            });
             
+            self.packetTimer = new Timer(new Date(), 32);
+            setInterval(function() { self.tick(); }, 16);
         },
 
+        tick: function() {
+        	var self = this;
+        	var time = new Date();
+        	if (self.packetTimer.isOver(time))
+        	{
+        		self.packetProcFunc();
+        		self.packetTimer.startTime = time;
+        		self.packetTimer.duration = self.packetInterval;
+        	}
+        },
+        
         enable: function() {
             this.isListening = true;
         },
@@ -561,6 +580,21 @@ define(['lib/pako', 'player', 'entityfactory', 'mob', 'mobdata', 'gather', 'gath
             }
         },
 
+        receiveMovePath: function(data) {
+            var map = data[1],
+            	id = data[2],
+                orientation = data[3],
+                path = JSON.parse(data[4]);
+
+            if (!this.game.map.isLoaded || this.game.mapIndex != map)
+            	return;
+            
+            //log.info("MOVEPATH");
+            if(this.movepath_callback) {
+                this.movepath_callback(map, id, orientation, path);
+            }
+        },
+
         receiveLootMove: function(data) {
             var map = data[1],
             	id = data[2],
@@ -1231,6 +1265,10 @@ define(['lib/pako', 'player', 'entityfactory', 'mob', 'mobdata', 'gather', 'gath
         onEntityMove: function(callback) {
             this.move_callback = callback;
         },
+        
+        onEntityMovePath: function(callback) {
+            this.movepath_callback = callback;
+        },
 
         onEntityAttack: function(callback) {
             this.attack_callback = callback;
@@ -1244,6 +1282,7 @@ define(['lib/pako', 'player', 'entityfactory', 'mob', 'mobdata', 'gather', 'gath
             this.equip_callback = callback;
         },*/
 
+        
         onPlayerMoveToItem: function(callback) {
             this.lootmove_callback = callback;
         },
@@ -1543,13 +1582,6 @@ define(['lib/pako', 'player', 'entityfactory', 'mob', 'mobdata', 'gather', 'gath
                               player.id]);
         },
 
-
-        /*sendMove: function(x, y) {
-            this.sendMessage([Types.Messages.MOVE,
-                              x,
-                              y]);
-        },*/
-
         // future move 1 for planned, 2 for arrived.
         sendMoveEntity: function(mapId, entity) {
             this.sendMessage([Types.Messages.MOVEENTITY,
@@ -1563,10 +1595,10 @@ define(['lib/pako', 'player', 'entityfactory', 'mob', 'mobdata', 'gather', 'gath
         },
 
         // future move 1 for planned, 2 for arrived.
-        sendMoveEntity2: function(mapId, id, gridX, gridY, future, orientation, target) {
+        sendMoveEntity2: function(id, mapId, gridX, gridY, future, orientation, target) {
             this.sendMessage([Types.Messages.MOVEENTITY,
-            		      mapId,
             		      id,
+            		      mapId,
                           gridX,
                           gridY,
             		      future,
@@ -1574,6 +1606,15 @@ define(['lib/pako', 'player', 'entityfactory', 'mob', 'mobdata', 'gather', 'gath
             			  target]);
         },
         
+        sendMovePath: function(mapId, id, length, path) {
+            var array = [Types.Messages.MOVEPATH,
+            		      mapId,
+            		      id,
+                          length];
+            array = array.concat(JSON.stringify(path));
+        	this.sendMessage(array);
+        },
+        
         sendLootMove: function(item, x, y) {
             this.sendMessage([Types.Messages.LOOTMOVE,
                               x,
@@ -1586,20 +1627,12 @@ define(['lib/pako', 'player', 'entityfactory', 'mob', 'mobdata', 'gather', 'gath
                               mob.id]);
         },
 
-        sendAttack: function(mob, timesAttack) {
+        sendAttack: function(player, mob) {
             this.sendMessage([Types.Messages.ATTACK,
-                              mob.id, timesAttack]);
+                              mob.id, player.gridX, player.gridY,
+            				  player.Orientation]);
         },
 
-        sendHit: function(mob, times) {
-            this.sendMessage([Types.Messages.HIT,
-                              mob.id, times]);
-        },
-
-        /*sendHurt: function(mob) {
-            this.sendMessage([Types.Messages.HURT,
-                              mob.id]);
-        },*/
         sendChat: function(text) {
             this.sendMessage([Types.Messages.CHAT,
                               text]);
diff --git a/js/map.js b/js/map.js
index 51ef08c..757b443 100644
--- a/js/map.js
+++ b/js/map.js
@@ -35,7 +35,7 @@ define(['jquery', 'area', 'detect', 'mapworker'], function($, Area, Detect, work
 					}
 					
 				}
-            },50);
+            },250);
         },
         
         _generate: function () {
diff --git a/shared/js/gametypes.js b/shared/js/gametypes.js
index 0cae338..dac7850 100644
--- a/shared/js/gametypes.js
+++ b/shared/js/gametypes.js
@@ -77,7 +77,7 @@ Types = {
         },
         TRADESCREEN: 50,
         CHARACTERINFO: 51,
-        FLAREDANCE: 52,
+        MOVEPATH: 52,
         SELL: 53,
         SHOP: 54,
         BUY: 55,
